# Database Schema and Data Model
## RCMD (Rclone Commander)

**Î¨∏ÏÑú Î≤ÑÏ†Ñ**: 1.0
**ÏûëÏÑ±Ïùº**: 2025-09-24
**Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§**: PostgreSQL 16 + Redis 7

---

## üìã Î™©Ï∞®
1. [Îç∞Ïù¥ÌÑ∞ Î™®Îç∏ Í∞úÏöî](#Îç∞Ïù¥ÌÑ∞-Î™®Îç∏-Í∞úÏöî)
2. [PostgreSQL Ïä§ÌÇ§Îßà](#postgresql-Ïä§ÌÇ§Îßà)
3. [Redis Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞](#redis-Îç∞Ïù¥ÌÑ∞-Íµ¨Ï°∞)
4. [Ïù∏Îç±Ïä§ Î∞è ÏµúÏ†ÅÌôî](#Ïù∏Îç±Ïä§-Î∞è-ÏµúÏ†ÅÌôî)
5. [Îç∞Ïù¥ÌÑ∞ Î¨¥Í≤∞ÏÑ± Î∞è Ï†úÏïΩÏÇ¨Ìï≠](#Îç∞Ïù¥ÌÑ∞-Î¨¥Í≤∞ÏÑ±-Î∞è-Ï†úÏïΩÏÇ¨Ìï≠)
6. [ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ï†ÑÎûµ](#ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò-Ï†ÑÎûµ)

---

## Îç∞Ïù¥ÌÑ∞ Î™®Îç∏ Í∞úÏöî

### ER Îã§Ïù¥Ïñ¥Í∑∏Îû®
```mermaid
erDiagram
    USERS ||--o{ SESSIONS : has
    USERS ||--o{ PERMISSIONS : has
    USERS ||--o{ AUDIT_LOGS : creates
    PERMISSIONS }o--|| REMOTES : references
    JOBS }o--|| USERS : created_by
    JOBS ||--o{ JOB_LOGS : has
    SCHEDULE_RULES ||--o{ SCHEDULED_JOBS : generates
    USERS ||--o{ USER_PREFERENCES : has
    NOTIFICATIONS }o--|| USERS : sent_to

    USERS {
        uuid id PK
        string username UK
        string email UK
        string password_hash
        enum role
        jsonb metadata
        timestamp created_at
        timestamp updated_at
    }

    SESSIONS {
        uuid id PK
        uuid user_id FK
        string token UK
        string refresh_token UK
        string ip_address
        string user_agent
        timestamp expires_at
        timestamp created_at
    }

    PERMISSIONS {
        uuid id PK
        uuid user_id FK
        string remote_id
        string[] permissions
        jsonb path_rules
        timestamp created_at
        timestamp updated_at
    }

    JOBS {
        uuid id PK
        uuid user_id FK
        enum type
        enum status
        integer progress
        jsonb payload
        jsonb result
        text error
        timestamp created_at
        timestamp started_at
        timestamp completed_at
    }
```

---

## PostgreSQL Ïä§ÌÇ§Îßà

### 1. Users Table
```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(20) NOT NULL DEFAULT 'user',
    is_active BOOLEAN DEFAULT true,
    is_verified BOOLEAN DEFAULT false,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    last_login_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT check_role CHECK (role IN ('admin', 'power_user', 'user')),
    CONSTRAINT check_email CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')
);

-- Ïù∏Îç±Ïä§
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_role ON users(role) WHERE is_active = true;
CREATE INDEX idx_users_metadata ON users USING GIN(metadata);

-- Ìä∏Î¶¨Í±∞
CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

### 2. Sessions Table
```sql
CREATE TABLE sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    token VARCHAR(500) UNIQUE NOT NULL,
    refresh_token VARCHAR(500) UNIQUE,
    ip_address INET,
    user_agent TEXT,
    device_info JSONB DEFAULT '{}',
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    refresh_expires_at TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    last_activity_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Ïù∏Îç±Ïä§
CREATE INDEX idx_sessions_user_id ON sessions(user_id);
CREATE UNIQUE INDEX idx_sessions_token ON sessions(token) WHERE is_active = true;
CREATE INDEX idx_sessions_expires ON sessions(expires_at) WHERE is_active = true;

-- ÏûêÎèô Ï†ïÎ¶¨Î•º ÏúÑÌïú ÌååÌã∞ÏÖîÎãù
CREATE TABLE sessions_2025_q1 PARTITION OF sessions
    FOR VALUES FROM ('2025-01-01') TO ('2025-04-01');
```

### 3. Permissions Table
```sql
CREATE TABLE permissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    remote_id VARCHAR(100) NOT NULL,
    permissions TEXT[] NOT NULL DEFAULT '{}',
    path_rules JSONB DEFAULT '[]',
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    created_by UUID REFERENCES users(id),
    CONSTRAINT unique_user_remote UNIQUE(user_id, remote_id),
    CONSTRAINT check_permissions CHECK (
        permissions <@ ARRAY['read', 'write', 'delete', 'admin']::text[]
    )
);

-- Ïù∏Îç±Ïä§
CREATE INDEX idx_permissions_user_remote ON permissions(user_id, remote_id);
CREATE INDEX idx_permissions_remote ON permissions(remote_id) WHERE is_active = true;
CREATE INDEX idx_permissions_path_rules ON permissions USING GIN(path_rules);

-- ÏòàÏãú path_rules Íµ¨Ï°∞
COMMENT ON COLUMN permissions.path_rules IS '
[
  {
    "path": "/public/*",
    "allow": ["read"],
    "deny": []
  },
  {
    "path": "/private/*",
    "allow": ["read", "write"],
    "deny": ["delete"]
  }
]';
```

### 4. Jobs Table
```sql
CREATE TABLE jobs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    type VARCHAR(50) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    priority INTEGER DEFAULT 5,
    progress INTEGER DEFAULT 0,
    payload JSONB NOT NULL,
    result JSONB,
    error TEXT,
    retry_count INTEGER DEFAULT 0,
    max_retries INTEGER DEFAULT 3,
    scheduled_for TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,
    cancelled_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT check_type CHECK (type IN ('copy', 'move', 'delete', 'sync', 'backup')),
    CONSTRAINT check_status CHECK (status IN ('pending', 'queued', 'running', 'completed', 'failed', 'cancelled')),
    CONSTRAINT check_progress CHECK (progress >= 0 AND progress <= 100),
    CONSTRAINT check_priority CHECK (priority >= 1 AND priority <= 10)
);

-- Ïù∏Îç±Ïä§
CREATE INDEX idx_jobs_user_id ON jobs(user_id);
CREATE INDEX idx_jobs_status ON jobs(status) WHERE status IN ('pending', 'queued', 'running');
CREATE INDEX idx_jobs_type_status ON jobs(type, status);
CREATE INDEX idx_jobs_created_at ON jobs(created_at DESC);
CREATE INDEX idx_jobs_scheduled ON jobs(scheduled_for) WHERE scheduled_for IS NOT NULL;

-- ÌååÌã∞ÏÖîÎãù (ÏõîÎ≥Ñ)
CREATE TABLE jobs_2025_01 PARTITION OF jobs
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
```

### 5. Job Logs Table
```sql
CREATE TABLE job_logs (
    id BIGSERIAL PRIMARY KEY,
    job_id UUID NOT NULL REFERENCES jobs(id) ON DELETE CASCADE,
    level VARCHAR(10) NOT NULL,
    message TEXT NOT NULL,
    details JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT check_level CHECK (level IN ('debug', 'info', 'warning', 'error', 'fatal'))
);

-- Ïù∏Îç±Ïä§
CREATE INDEX idx_job_logs_job_id ON job_logs(job_id);
CREATE INDEX idx_job_logs_level ON job_logs(level) WHERE level IN ('error', 'fatal');
CREATE INDEX idx_job_logs_created ON job_logs(created_at DESC);

-- ÏûêÎèô Ï†ïÎ¶¨ (30Ïùº Ïù¥ÏÉÅ Îêú Î°úÍ∑∏ ÏÇ≠Ï†ú)
CREATE INDEX idx_job_logs_cleanup ON job_logs(created_at)
    WHERE created_at < CURRENT_DATE - INTERVAL '30 days';
```

### 6. Audit Logs Table
```sql
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID REFERENCES users(id),
    action VARCHAR(100) NOT NULL,
    resource_type VARCHAR(50),
    resource_id VARCHAR(255),
    details JSONB,
    ip_address INET,
    user_agent TEXT,
    result VARCHAR(20),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT check_result CHECK (result IN ('success', 'failure', 'error'))
) PARTITION BY RANGE (created_at);

-- ÏõîÎ≥Ñ ÌååÌã∞ÏÖò
CREATE TABLE audit_logs_2025_01 PARTITION OF audit_logs
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- Ïù∏Îç±Ïä§
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_created ON audit_logs(created_at DESC);
CREATE INDEX idx_audit_logs_resource ON audit_logs(resource_type, resource_id);
```

### 7. Schedule Rules Table
```sql
CREATE TABLE schedule_rules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    is_active BOOLEAN DEFAULT true,
    rule_type VARCHAR(20) NOT NULL,
    cron_expression VARCHAR(100),
    interval_seconds INTEGER,
    job_template JSONB NOT NULL,
    last_run_at TIMESTAMP WITH TIME ZONE,
    next_run_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT check_rule_type CHECK (rule_type IN ('cron', 'interval', 'once')),
    CONSTRAINT check_cron_or_interval CHECK (
        (rule_type = 'cron' AND cron_expression IS NOT NULL) OR
        (rule_type = 'interval' AND interval_seconds IS NOT NULL) OR
        (rule_type = 'once')
    )
);

-- Ïù∏Îç±Ïä§
CREATE INDEX idx_schedule_rules_user ON schedule_rules(user_id) WHERE is_active = true;
CREATE INDEX idx_schedule_rules_next_run ON schedule_rules(next_run_at) WHERE is_active = true;
```

### 8. User Preferences Table
```sql
CREATE TABLE user_preferences (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    theme VARCHAR(20) DEFAULT 'light',
    language VARCHAR(10) DEFAULT 'en',
    timezone VARCHAR(50) DEFAULT 'UTC',
    notifications JSONB DEFAULT '{}',
    ui_settings JSONB DEFAULT '{}',
    api_settings JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Ïù∏Îç±Ïä§
CREATE UNIQUE INDEX idx_user_preferences_user ON user_preferences(user_id);
```

### 9. Notifications Table
```sql
CREATE TABLE notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    type VARCHAR(50) NOT NULL,
    title VARCHAR(255) NOT NULL,
    message TEXT,
    data JSONB,
    is_read BOOLEAN DEFAULT false,
    is_archived BOOLEAN DEFAULT false,
    priority VARCHAR(10) DEFAULT 'normal',
    expires_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    read_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT check_priority CHECK (priority IN ('low', 'normal', 'high', 'urgent'))
);

-- Ïù∏Îç±Ïä§
CREATE INDEX idx_notifications_user ON notifications(user_id, is_read, is_archived);
CREATE INDEX idx_notifications_created ON notifications(created_at DESC);
CREATE INDEX idx_notifications_expires ON notifications(expires_at) WHERE expires_at IS NOT NULL;
```

---

## Redis Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞

### 1. ÏÑ∏ÏÖò Í¥ÄÎ¶¨
```redis
# ÏÇ¨Ïö©Ïûê ÏÑ∏ÏÖò
session:{session_id} = {
    "userId": "uuid",
    "username": "string",
    "role": "admin",
    "permissions": ["read", "write"],
    "createdAt": 1609459200,
    "expiresAt": 1609545600
}
TTL: 86400 (24ÏãúÍ∞Ñ)

# ÌôúÏÑ± ÏÑ∏ÏÖò Î™©Î°ù
user:sessions:{user_id} = SET[session_id1, session_id2]
```

### 2. Ï∫êÏãú Í¥ÄÎ¶¨
```redis
# Î¶¨Î™®Ìä∏ Î™©Î°ù Ï∫êÏãú
cache:remotes:{user_id} = [
    {
        "id": "gdrive",
        "name": "Google Drive",
        "status": "online"
    }
]
TTL: 300 (5Î∂Ñ)

# ÌååÏùº Î™©Î°ù Ï∫êÏãú
cache:files:{remote_id}:{path_hash} = [
    {
        "name": "file.txt",
        "size": 1024,
        "modTime": "2025-09-24T10:00:00Z"
    }
]
TTL: 60 (1Î∂Ñ)

# Í∂åÌïú Ï∫êÏãú
cache:permissions:{user_id}:{remote_id} = ["read", "write"]
TTL: 600 (10Î∂Ñ)
```

### 3. ÏûëÏóÖ ÌÅê
```redis
# ÏûëÏóÖ ÌÅê (Bull Queue)
bull:jobs:wait = LIST[job_id1, job_id2]
bull:jobs:active = LIST[job_id3]
bull:jobs:completed = SET[job_id4, job_id5]
bull:jobs:failed = SET[job_id6]

# ÏûëÏóÖ ÏÉÅÏÑ∏ Ï†ïÎ≥¥
bull:jobs:{job_id} = {
    "id": "job_uuid",
    "type": "copy",
    "status": "running",
    "progress": 45,
    "data": {...}
}
```

### 4. Rate Limiting
```redis
# API Rate Limiting (Sliding Window)
rate:api:{user_id}:{endpoint} = ZSET[
    timestamp1: request_id1,
    timestamp2: request_id2
]
TTL: 60 (1Î∂Ñ ÏúàÎèÑÏö∞)

# Î°úÍ∑∏Ïù∏ ÏãúÎèÑ Ï†úÌïú
rate:login:{ip_address} = INCR
TTL: 300 (5Î∂Ñ)
```

### 5. Ïã§ÏãúÍ∞Ñ ÌÜµÏã†
```redis
# SSE ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï∂îÏ†Å
sse:clients = SET[client_id1, client_id2]
sse:client:{client_id} = {
    "userId": "uuid",
    "connectedAt": 1609459200,
    "channels": ["remotes", "jobs"]
}

# Pub/Sub Ï±ÑÎÑê
pubsub:remotes = "remote status updates"
pubsub:jobs = "job progress updates"
pubsub:notifications = "user notifications"
```

### 6. Î∂ÑÏÇ∞ Ïû†Í∏à
```redis
# Î¶¨ÏÜåÏä§ Ïû†Í∏à (Redlock)
lock:remote:{remote_id} = "lock_value"
TTL: 30 (30Ï¥à)

lock:job:{job_id} = "worker_id"
TTL: 300 (5Î∂Ñ)
```

### 7. ÌÜµÍ≥Ñ Î∞è Î©îÌä∏Î¶≠
```redis
# Ïπ¥Ïö¥ÌÑ∞
stats:api:calls:{date} = INCR
stats:jobs:completed:{date} = INCR
stats:errors:{date}:{error_type} = INCR

# ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞
timeseries:api:response_time = TS.ADD(timestamp, value)
timeseries:jobs:queue_size = TS.ADD(timestamp, value)
```

---

## Ïù∏Îç±Ïä§ Î∞è ÏµúÏ†ÅÌôî

### PostgreSQL Ïù∏Îç±Ïä§ Ï†ÑÎûµ

#### 1. Î≥µÌï© Ïù∏Îç±Ïä§
```sql
-- ÏûêÏ£º Ìï®Íªò Ï°∞ÌöåÎêòÎäî Ïª¨Îüº
CREATE INDEX idx_jobs_user_status_created
    ON jobs(user_id, status, created_at DESC)
    WHERE status IN ('pending', 'running');

CREATE INDEX idx_permissions_user_remote_active
    ON permissions(user_id, remote_id)
    WHERE is_active = true;
```

#### 2. Î∂ÄÎ∂Ñ Ïù∏Îç±Ïä§
```sql
-- ÌôúÏÑ± ÏÇ¨Ïö©ÏûêÎßå Ïù∏Îç±Ïã±
CREATE INDEX idx_users_active
    ON users(username)
    WHERE is_active = true;

-- ÏµúÍ∑º ÏûëÏóÖÎßå Ïù∏Îç±Ïã±
CREATE INDEX idx_jobs_recent
    ON jobs(created_at DESC)
    WHERE created_at > CURRENT_DATE - INTERVAL '7 days';
```

#### 3. ÌëúÌòÑÏãù Ïù∏Îç±Ïä§
```sql
-- ÎåÄÏÜåÎ¨∏Ïûê Íµ¨Î∂Ñ ÏóÜÎäî Í≤ÄÏÉâ
CREATE INDEX idx_users_username_lower
    ON users(LOWER(username));

-- JSONB ÌïÑÎìú Ïù∏Îç±Ïã±
CREATE INDEX idx_permissions_path_rules_paths
    ON permissions USING GIN((path_rules->'paths'));
```

### ÏøºÎ¶¨ ÏµúÏ†ÅÌôî ÏòàÏãú

#### 1. Ìö®Ïú®Ï†ÅÏù∏ ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò
```sql
-- Keyset Pagination (Ìö®Ïú®Ï†Å)
SELECT * FROM jobs
WHERE user_id = $1
  AND (created_at, id) < ($2, $3)
ORDER BY created_at DESC, id DESC
LIMIT 20;

-- EXPLAIN ANALYZE Í≤∞Í≥º
-- Index Scan using idx_jobs_user_status_created
-- Planning Time: 0.2 ms
-- Execution Time: 0.5 ms
```

#### 2. JSONB ÏøºÎ¶¨ ÏµúÏ†ÅÌôî
```sql
-- Ìö®Ïú®Ï†ÅÏù∏ JSONB ÏøºÎ¶¨
SELECT * FROM permissions
WHERE user_id = $1
  AND path_rules @> '[{"path": "/documents/*"}]';

-- GIN Ïù∏Îç±Ïä§ ÌôúÏö©
CREATE INDEX idx_permissions_paths
    ON permissions USING GIN(path_rules jsonb_path_ops);
```

---

## Îç∞Ïù¥ÌÑ∞ Î¨¥Í≤∞ÏÑ± Î∞è Ï†úÏïΩÏÇ¨Ìï≠

### 1. Foreign Key Ï†úÏïΩ
```sql
-- Cascade ÏÇ≠Ï†ú
ALTER TABLE sessions
    ADD CONSTRAINT fk_sessions_user
    FOREIGN KEY (user_id)
    REFERENCES users(id)
    ON DELETE CASCADE;

-- Restrict ÏÇ≠Ï†ú
ALTER TABLE audit_logs
    ADD CONSTRAINT fk_audit_logs_user
    FOREIGN KEY (user_id)
    REFERENCES users(id)
    ON DELETE RESTRICT;
```

### 2. Check Ï†úÏïΩ
```sql
-- Ïù¥Î©îÏùº ÌòïÏãù Í≤ÄÏ¶ù
ALTER TABLE users
    ADD CONSTRAINT check_email_format
    CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$');

-- ÎÇ†Ïßú ÎÖºÎ¶¨ Í≤ÄÏ¶ù
ALTER TABLE jobs
    ADD CONSTRAINT check_job_dates
    CHECK (
        (started_at IS NULL OR started_at >= created_at) AND
        (completed_at IS NULL OR completed_at >= started_at)
    );
```

### 3. Unique Ï†úÏïΩ
```sql
-- Î≥µÌï© Ïú†ÎãàÌÅ¨ Ï†úÏïΩ
ALTER TABLE permissions
    ADD CONSTRAINT unique_user_remote_permission
    UNIQUE (user_id, remote_id);

-- Ï°∞Í±¥Î∂Ä Ïú†ÎãàÌÅ¨ Ï†úÏïΩ
CREATE UNIQUE INDEX unique_active_session_token
    ON sessions(token)
    WHERE is_active = true;
```

### 4. Ìä∏Î¶¨Í±∞
```sql
-- updated_at ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Í∞êÏÇ¨ Î°úÍ∑∏ ÏûêÎèô ÏÉùÏÑ±
CREATE OR REPLACE FUNCTION create_audit_log()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit_logs (user_id, action, resource_type, resource_id, details)
    VALUES (
        current_setting('app.current_user_id')::UUID,
        TG_OP,
        TG_TABLE_NAME,
        NEW.id::VARCHAR,
        to_jsonb(NEW)
    );
    RETURN NEW;
END;
$$ language 'plpgsql';
```

---

## ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ï†ÑÎûµ

### 1. ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÌååÏùº Íµ¨Ï°∞
```
migrations/
‚îú‚îÄ‚îÄ 001_initial_schema.sql
‚îú‚îÄ‚îÄ 002_add_sessions_table.sql
‚îú‚îÄ‚îÄ 003_add_permissions_table.sql
‚îú‚îÄ‚îÄ 004_add_jobs_tables.sql
‚îú‚îÄ‚îÄ 005_add_audit_logs.sql
‚îú‚îÄ‚îÄ 006_add_indexes.sql
‚îú‚îÄ‚îÄ 007_add_partitioning.sql
‚îî‚îÄ‚îÄ rollback/
    ‚îú‚îÄ‚îÄ 007_rollback.sql
    ‚îú‚îÄ‚îÄ 006_rollback.sql
    ‚îî‚îÄ‚îÄ ...
```

### 2. ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïä§ÌÅ¨Î¶ΩÌä∏ ÏòàÏãú
```sql
-- migrations/001_initial_schema.sql
BEGIN;

-- ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Î©îÌÉÄÎç∞Ïù¥ÌÑ∞
CREATE TABLE IF NOT EXISTS schema_migrations (
    version INTEGER PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    executed_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Users ÌÖåÏù¥Î∏î ÏÉùÏÑ±
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(50) UNIQUE NOT NULL,
    -- ... ÎÇòÎ®∏ÏßÄ Ïä§ÌÇ§Îßà
);

-- ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Í∏∞Î°ù
INSERT INTO schema_migrations (version, name)
VALUES (1, 'initial_schema');

COMMIT;
```

### 3. Drizzle ORM ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
```typescript
// drizzle.config.ts
import type { Config } from 'drizzle-kit';

export default {
  schema: './src/lib/server/database/schema.ts',
  out: './migrations',
  driver: 'pg',
  dbCredentials: {
    connectionString: process.env.DATABASE_URL!
  },
  verbose: true,
  strict: true
} satisfies Config;

// package.json scripts
{
  "db:generate": "drizzle-kit generate:pg",
  "db:push": "drizzle-kit push:pg",
  "db:migrate": "tsx src/lib/server/database/migrate.ts",
  "db:studio": "drizzle-kit studio"
}
```

### 4. Î∞±ÏóÖ Î∞è Î≥µÍµ¨
```bash
#!/bin/bash
# backup.sh

# Ï†ÑÏ≤¥ Î∞±ÏóÖ
pg_dump -h localhost -U postgres -d rcmd \
    --format=custom \
    --file=backup_$(date +%Y%m%d_%H%M%S).dump

# ÌäπÏ†ï ÌÖåÏù¥Î∏î Î∞±ÏóÖ
pg_dump -h localhost -U postgres -d rcmd \
    --table=users --table=permissions \
    --format=custom \
    --file=users_backup.dump

# Î≥µÍµ¨
pg_restore -h localhost -U postgres -d rcmd \
    --clean --if-exists \
    backup_20250924_100000.dump

# Redis Î∞±ÏóÖ
redis-cli --rdb backup.rdb
```

---

## ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ ÏøºÎ¶¨

### 1. ÎäêÎ¶∞ ÏøºÎ¶¨ Ï∞æÍ∏∞
```sql
-- ÎäêÎ¶∞ ÏøºÎ¶¨ ÏÉÅÏúÑ 10Í∞ú
SELECT
    query,
    mean_exec_time,
    calls,
    total_exec_time,
    min_exec_time,
    max_exec_time
FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 10;
```

### 2. Ïù∏Îç±Ïä§ ÏÇ¨Ïö©Î•†
```sql
-- ÏÇ¨Ïö©ÎêòÏßÄ ÏïäÎäî Ïù∏Îç±Ïä§
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE idx_scan = 0
ORDER BY tablename, indexname;
```

### 3. ÌÖåÏù¥Î∏î ÌÅ¨Í∏∞ Î™®ÎãàÌÑ∞ÎßÅ
```sql
-- ÌÖåÏù¥Î∏îÎ≥Ñ ÌÅ¨Í∏∞
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) -
                   pg_relation_size(schemaname||'.'||tablename)) AS indexes_size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

### 4. Ïó∞Í≤∞ Î™®ÎãàÌÑ∞ÎßÅ
```sql
-- ÌôúÏÑ± Ïó∞Í≤∞ ÌôïÏù∏
SELECT
    pid,
    usename,
    application_name,
    client_addr,
    state,
    query_start,
    state_change,
    query
FROM pg_stat_activity
WHERE state != 'idle'
ORDER BY query_start DESC;
```

---

## Î∂ÄÎ°ù

### A. Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖ Í∞ÄÏù¥Îìú
| PostgreSQL Type | TypeScript Type | Ïö©ÎèÑ |
|----------------|-----------------|------|
| UUID | string | Ï£ºÌÇ§, Ïô∏ÎûòÌÇ§ |
| VARCHAR | string | ÌÖçÏä§Ìä∏ Îç∞Ïù¥ÌÑ∞ |
| TEXT | string | Í∏¥ ÌÖçÏä§Ìä∏ |
| JSONB | object | Íµ¨Ï°∞ÌôîÎêú Îç∞Ïù¥ÌÑ∞ |
| TIMESTAMP WITH TIME ZONE | Date | ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ |
| INTEGER | number | Ï†ïÏàò |
| BOOLEAN | boolean | Î∂àÎ¶∞ Í∞í |
| INET | string | IP Ï£ºÏÜå |
| TEXT[] | string[] | Î∞∞Ïó¥ Îç∞Ïù¥ÌÑ∞ |

### B. ÎÑ§Ïù¥Î∞ç Ïª®Î≤§ÏÖò
```sql
-- ÌÖåÏù¥Î∏î: Î≥µÏàòÌòï, snake_case
CREATE TABLE users (...);

-- Ïª¨Îüº: snake_case
created_at TIMESTAMP;

-- Ïù∏Îç±Ïä§: idx_ÌÖåÏù¥Î∏îÎ™Ö_Ïª¨ÎüºÎ™Ö
CREATE INDEX idx_users_email;

-- Ï†úÏïΩÏÇ¨Ìï≠: ÌÉÄÏûÖ_ÌÖåÏù¥Î∏îÎ™Ö_ÏÑ§Î™Ö
CONSTRAINT check_users_email;
CONSTRAINT fk_sessions_user;
CONSTRAINT unique_user_remote;
```

### C. ÌååÌã∞ÏÖîÎãù Ï†ÑÎûµ
```sql
-- ÏãúÍ∞Ñ Í∏∞Î∞ò ÌååÌã∞ÏÖîÎãù (ÏõîÎ≥Ñ)
CREATE TABLE audit_logs_2025_01 PARTITION OF audit_logs
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- ÏûêÎèô ÌååÌã∞ÏÖò ÏÉùÏÑ±
CREATE OR REPLACE FUNCTION create_monthly_partition()
RETURNS void AS $$
DECLARE
    partition_name TEXT;
    start_date DATE;
    end_date DATE;
BEGIN
    start_date := DATE_TRUNC('month', CURRENT_DATE);
    end_date := start_date + INTERVAL '1 month';
    partition_name := 'audit_logs_' || TO_CHAR(start_date, 'YYYY_MM');

    EXECUTE format(
        'CREATE TABLE IF NOT EXISTS %I PARTITION OF audit_logs
         FOR VALUES FROM (%L) TO (%L)',
        partition_name, start_date, end_date
    );
END;
$$ LANGUAGE plpgsql;

-- Îß§Ïõî Ïã§Ìñâ
SELECT cron.schedule('create-partition', '0 0 1 * *', 'SELECT create_monthly_partition()');
```

---

**Î¨∏ÏÑú ÏôÑÎ£å**: 2025-09-24
**Îã§Ïùå Îã®Í≥Ñ**: ÌîÑÎ°úÏ†ùÌä∏ Íµ¨ÌòÑ ÏãúÏûë